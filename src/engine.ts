/**
 * instrux - Core engine
 *
 * Loads agent configs, validates source files, and either:
 *   - Simple merge: concatenates files in order (v1)
 *   - Compile: resolves Handlebars templates + frontmatter tags (v2)
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import * as crypto from 'crypto';
import {
  AgentConfig,
  BuildResult,
  ValidationResult,
} from './types';
import { InstruxCompiler } from './compiler';

export class InstruxEngine {
  private rootDir: string;

  constructor(rootDir?: string) {
    this.rootDir = rootDir ?? process.cwd();
  }

  // ── Config loading ───────────────────────────────────────

  /**
   * Resolve the config path for a given agent name.
   * Looks in `agents/<name>/agent.json`.
   */
  private agentConfigPath(agentName: string): string {
    return path.join(this.rootDir, 'agents', agentName, 'agent.json');
  }

  /**
   * Load an agent configuration by name.
   */
  async loadConfig(agentName: string): Promise<AgentConfig> {
    const configPath = this.agentConfigPath(agentName);

    if (!(await fs.pathExists(configPath))) {
      throw new Error(
        `Agent config not found: ${path.relative(this.rootDir, configPath)}\n` +
        `Run "instrux init <name>" to create one.`
      );
    }

    const raw = await fs.readFile(configPath, 'utf-8');
    return JSON.parse(raw) as AgentConfig;
  }

  // ── Discovery ────────────────────────────────────────────

  /**
   * List all agents found in the `agents/` directory.
   */
  async listAgents(): Promise<{ name: string; config: AgentConfig | null }[]> {
    const agentsDir = path.join(this.rootDir, 'agents');

    if (!(await fs.pathExists(agentsDir))) {
      return [];
    }

    const entries = await fs.readdir(agentsDir, { withFileTypes: true });
    const dirs = entries.filter(e => e.isDirectory() && e.name !== 'base');

    const agents: { name: string; config: AgentConfig | null }[] = [];

    for (const dir of dirs) {
      const configPath = path.join(agentsDir, dir.name, 'agent.json');
      let config: AgentConfig | null = null;

      if (await fs.pathExists(configPath)) {
        try {
          config = JSON.parse(await fs.readFile(configPath, 'utf-8'));
        } catch {
          // invalid JSON — still list the directory
        }
      }

      agents.push({ name: dir.name, config });
    }

    return agents;
  }

  // ── Validation ───────────────────────────────────────────

  async validate(config: AgentConfig): Promise<ValidationResult> {
    const missing: string[] = [];
    const warnings: string[] = [];

    const files = config.files ?? [];
    for (const file of files) {
      const fullPath = path.join(this.rootDir, file.path);
      const exists = await fs.pathExists(fullPath);

      if (!exists && file.required) {
        missing.push(file.path);
      } else if (!exists && !file.required) {
        warnings.push(`Optional file not found: ${file.path}`);
      }
    }

    return { valid: missing.length === 0, missing, warnings };
  }

  // ── Merge ────────────────────────────────────────────────

  async merge(config: AgentConfig): Promise<string> {
    const { mergeSettings } = config;
    let merged = '';
    let first = true;

    const files = config.files ?? [];

    if (mergeSettings.includeFileHeaders) {
      merged += `<!-- Generated by instrux -->\n`;
      merged += `<!-- Agent: ${config.name} -->\n`;
      merged += `<!-- Generated: ${new Date().toISOString()} -->\n\n`;
    }

    for (const file of files) {
      const fullPath = path.join(this.rootDir, file.path);
      let content = '';

      if (await fs.pathExists(fullPath)) {
        content = await fs.readFile(fullPath, 'utf-8');
      }

      if (!content || content.trim().length === 0) {
        const kind = file.required ? 'required' : 'optional';
        console.log(`  ⚠  Skipping empty ${kind} file: ${file.path}`);
        continue;
      }

      // separator between sections (not before the first)
      if (!first && mergeSettings.addSeparators) {
        merged += `\n${mergeSettings.separatorStyle}\n\n`;
      }

      if (mergeSettings.includeFileHeaders) {
        merged += `<!-- File: ${file.path} -->\n`;
        merged += `<!-- ${file.description} -->\n\n`;
      }

      merged += content;
      if (!content.endsWith('\n')) merged += '\n';
      first = false;
    }

    return merged;
  }

  // ── Write output ─────────────────────────────────────────

  async writeOutput(config: AgentConfig, content: string): Promise<string> {
    const outputDir = path.join(this.rootDir, config.outputDirectory);
    await fs.ensureDir(outputDir);

    let fileName = config.outputFilePattern;

    if (config.mergeSettings.useTimestamp) {
      const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      fileName = fileName.replace('{timestamp}', ts);
    } else {
      fileName = fileName
        .replace('_{timestamp}', '')
        .replace('{timestamp}_', '')
        .replace('{timestamp}', '');
    }

    if (config.mergeSettings.generateHash) {
      const hash = this.contentHash(content);
      fileName = fileName.replace('.md', `_${hash}.md`);
    }

    const outputPath = path.join(outputDir, fileName);
    await fs.writeFile(outputPath, content, 'utf-8');
    return outputPath;
  }

  // ── Build (validate → merge/compile → write) ───────────

  /**
   * Returns true if the agent config uses the template compiler (v2)
   * instead of simple ordered merge.
   */
  isCompileMode(config: AgentConfig): boolean {
    return !!config.entry;
  }

  async build(agentName: string): Promise<BuildResult> {
    const config = await this.loadConfig(agentName);

    // ── Template compilation mode ──────────────────────
    if (this.isCompileMode(config)) {
      const compiler = new InstruxCompiler(this.rootDir, config);
      const result = await compiler.compile();

      const outputPath = await this.writeOutput(config, result.output);

      return {
        outputPath: path.relative(this.rootDir, outputPath),
        contentLength: result.output.length,
        contentHash: this.contentHash(result.output),
        filesIncluded: result.filesCompiled,
        filesSkipped: 0,
      };
    }

    // ── Simple merge mode (v1) ─────────────────────────
    if (!config.files || config.files.length === 0) {
      throw new Error(
        'Agent config must define either "entry" (template mode) or "files" (simple merge mode).'
      );
    }

    const validation = await this.validate(config);
    for (const w of validation.warnings) console.log(`  ⚠  ${w}`);
    if (!validation.valid) {
      throw new Error(
        `Missing required files:\n${validation.missing.map(f => `  - ${f}`).join('\n')}`
      );
    }

    const content = await this.merge(config);
    const outputPath = await this.writeOutput(config, content);

    return {
      outputPath: path.relative(this.rootDir, outputPath),
      contentLength: content.length,
      contentHash: this.contentHash(content),
      filesIncluded: config.files.length,
      filesSkipped: 0,
    };
  }

  // ── Helpers ──────────────────────────────────────────────

  contentHash(content: string): string {
    return crypto
      .createHash('md5')
      .update(content)
      .digest('hex')
      .substring(0, 8);
  }
}
